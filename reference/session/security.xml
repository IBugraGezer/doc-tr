<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 184f3f7bd45643cb80f828d0bb001991ec3a5fad Maintainer: nilgun Status: wip -->
<chapter xml:id="session.security" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Oturumlar ve Güvenlik</title>
 <para>
  Dış bağlantı: <link xlink:href="&url.session-fixation;">Oturum Tespiti</link>
 </para>
 <para>
  HTTP oturum yönetimi, site güvenliğinin özünü temsil eder. Oturumların
  güvence altına alınmasını sağlamak için tüm olası etki azaltma önlemleri
  ALINMALIDIR. Geliştiriciler ayrıca uygulanabilir güvenlik önlemlerini
  etkinleştirmeli ve kullanmalıdır.
 </para>

  <sect1 xml:id="features.session.security.management">
   <title>Oturum Yönetiminin Temelleri</title>

   <sect2 xml:id="features.session.security.management.basic">
    <title>Oturum Güvenliği</title>
    <para>
     Oturum modülü bir oturumda saklanan verinin sadece oturumun kullanıcısı
     tarafından görüldüğünü garanti edemez. Oturumun bütünlüğünü etkin olarak
     korumak için oturumun önemine bağlı olarak ek tedbirler alınması gerekir.
    </para>
    <para>
     Oturumlarınız tarafından taşınan verinin önemine ve konuşlandırdığınız ek
     korumalara bağlı olarak ki, bunun bir fiyatı vardır, kullanıcının rahatı
     azalır. Örneğin, kullanıcılarınızı basit sosyal mühendislik
     taktiklerinden korumak için <link linkend="ini.session.use-only-cookies">
     <parameter>session.use_only_cookies</parameter></link> yönergesi etkin
     kılınmalıdır. Bu durumda, çerezler kullanıcı tarafında koşulsuz olarak
     etkin kılınmalıdır yoksa oturum çalışmayacaktır.
    </para>
    <para>
     Bir mevcut oturum kimliğinin üçüncü şahıslara ifşa olmasının çeşitli
     yolları vardır. Örneğin, JavaScript zerkleri, URL'lerdeki oturum
     kimlikleri, paket koklama, cihaza fiziksel erişim vb. İfşa edilmiş bir
     oturum kimliği, üçüncü tarafın o kimlik ile ilişkilendirilmiş tüm
     özkaynaklara erişmesini mümkün kılar. İlk olarak oturum kimliğini taşıyan
     URL'ler ifşa olur. Harici bir siteye bir bağ verilirse oturum kimliğini
     içeren URL, harici sitenin günlük kayıtlarına geçebilir. İkinci olarak,
     daha etkin bir saldırgan ağ trafiğini dinleyebilir. Eğer şifreleme
     yapılmıyorsa oturum kimlikleri ağ üzerinden salt metin olarak akacaktır.
     Bu noktada çözüm, sunucunuzun SSL bağlantılar kurmasını sağlamak ve bunu
     kullanıcılarınız için zorunlu kılmaktır. Güvenliği arttırmak için HSTS
     kullanılmalıdır.
    </para>
   <note>
    <simpara>
     HTTPS bile gizli verileri her zaman koruyamaz. Örneğin, CRIME ve Beast
     güvenlik açıkları, bir saldırganın verileri okumasını sağlayabilir.
     Ayrıca, birçok ağın denetim amacıyla HTTPS MITM vekilleri kullandığı
     unutulmamalıdır. Saldırganlar da böyle bir vekil sunucu kurabilir.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="features.session.security.management.non-adaptive-session">
   <title>Uyumsuz Oturum Yönetimi </title>
   <para>
    PHP'nin oturum yöneticisi şu anda öntanımlı olarak uyarlanabilir
    durumdadır. Uyarlanabilir bir oturum yöneticisi ek riskler içerir.
   </para>
   <para>
    <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
    etkin olduğunda ve oturum kayıt işleyicisi
    destekliyorsa, ilklendirilmemiş bir oturum kimliği reddedilir ve yenisi
    oluşturulur. Bu, kullanıcıyı bilinen bir oturum kimliğini kullanmaya
    zorlayan bir saldırıyı engeller. Bir saldırgan bağlantıları kopyalayabilir
    ve oturum kimliği içeren bağlantıları epostalarda yollayabilir. Örneğin,
   <literal>http://example.com/page.php?PHPSESSID=123456789</literal> eğer
    <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link>
    etkinse, kurban, saldırgan tarafından sağlanan oturum kimliğini kullanarak
    bir oturum başlatacaktır.
    <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
    bu riski azaltır.
   </para>
   <warning>
    <simpara>
     Kullanıcı tanımlı kayıt işleyicileri, oturum kimliği doğrulaması
     uygulayarak katı oturum kipini destekleyebilir. Tüm kullanıcı tanımlı
     kayıt işleyicileri, oturum kimliği doğrulamasını gerçeklemelidir.
    </simpara>
   </warning>
   <para>
    Oturum kimliği çerezine domain, path, httponly, secure ve PHP 7.3 ve
    sonrasında SameSite öznitelikleri atanabilir.
    <!-- Not exactly sure what the meaning here is - girgias -->
    Tarayıcılarda tanımlı öncelikler vardır. Öncelik kullanarak bir
    saldırganın kalıcı olarak kullanılabilecek oturum kimliği ataması
    mümkündür. <link
    linkend="ini.session.use-only-cookies">session.use_only_cookies</link>
    kullanımı bu sorunu çözümlemez.
    <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
    bu riski azaltır. <link
    linkend="ini.session.use-strict-mode">session.use_strict_mode</link>=On
    ile ilklendirilmemiş bir oturum kimliği reddedilir.
   </para>
   <note>
    <simpara><link
     linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
     uyarlanabilir oturum yönetimi riskini azaltsa da, bir saldırgan
     yine de kullanıcıyı ilklendirilmemiş bir oturum kimliğini kullanmaya
     zorlayabilir; böyle bir oturum kimliği saldırgan tarafından JavaScript
     zerki ile oluşturulabilir. Bu saldırının riskleri bu kılavuzun
     tavsiyelerine uyularak azaltılabilir.
    </simpara>
    <simpara>
     Bu kılavuzu izleyerek, geliştiriciler, <link
     linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
     yönergesini etkin kılmalı, zaman damgalı oturum yönetimi kullanmalı ve
     tavsiye edilen yordamlarla <function>session_regenerate_id</function>
     kullanarak oturum kimliklerini yeniden üretmelidir. Geliştirici
     yukarıdakilerin tümünü uyguladığı takdirde saldırgan üretimi oturum
     kimliği silinecektir.
    </simpara>
    <simpara>
     Eski bir oturuma erişim gerçekleştiğinde, bu bilgiler, müteakip bir
     soruşturma için geçerli olacağından, geliştiriciler kullanıcının
     tüm etkin oturum verilerini kaydetmelidir. Kullanıcının tüm oturumları
     zorla kapatılmalı ve yeniden kimlik doğrulaması yapması istenmelidir.
     Bu, saldırganların çalınan oturumları kötü amaçlarla kullanmasını
     engeller.
    </simpara>
   </note>
   <warning>
    <simpara>
     Eski bir oturuma erişim, mutlaka bir saldırı anlamına gelmez. Kararsız
     bir ağ ve/veya etkin oturumun derhal silinmesi, meşru kullanıcıların
     eski oturumlarını kullanmasına sebep olacaktır.
    </simpara>
   </warning>
   <para>
    PHP 7.1.0 ve sonrası için, <function>session_create_id</function> eklendi.
    Bu işlev, bir kullanıcının oturum kimliklerinin önüne kullanıcı kimliği
    eklenerek tüm etkin oturumlarına verimli bir şekilde erişmek için
    çalıştırılabilir. <link
    linkend="ini.session.use-strict-mode">session.use_strict_mode</link>'u
    etkinleştirmek bu gerçeklenim için çok önemlidir. Aksi takdirde, kötü
    niyetli kullanıcılar diğer kullanıcılar için kötü amaçlı bir oturum
    kimliği atayabilir.
   </para>
   <note>
    <simpara>
     PHP 7.1.0 öncesinde gelitiriciler yeni bir oturum kimliği üretmek için
     /dev/urandom gibi bir CSPRNG veya aş işlevlerini ve
     <function>random_bytes</function> işlevini kullanmalıdır.
     <function>session_create_id</function> çakışma algılama özelliğine
     sahiptir ve oturumun INI ayarlarına göre bir oturum kimliği üretir.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="features.session.security.management.session-id-regeneration">
   <title>Oturum Kimliğinin Yeniden Üretilmesi</title>
   <para>
    <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
    iyi bir acı azaltıcıdır ancak yetersizdir. Geliştiriciler oturum
    güvenliğini sağlamak için aynı zamanda
    <function>session_regenerate_id</function> işlevini de kullanmalıdır.
   </para>
   <para>
    Oturum kimliğinin yenilenmesi oturum kimliklerinin çalınma riskini
    azaltır, bu bakımdan <function>session_regenerate_id</function> belirli
    aralıklarla sürekli çağrılmalıdır. Örneğin, güvenlik açısından hassas
    içerik için oturum kimliğini her 15 dakikada bir yeniden oluşturun. Bir
    oturum kimliğinin çalınması durumunda bile, hem meşru kullanıcının hem de
    saldırganın oturumu sona erecektir. Başka bir deyişle, kullanıcı veya
    saldırgan tarafından erişim, eski bir oturuma erişim hatası üretecektir.
   </para>

   <para>
    Oturum kimlikleri, kullanıcı ayrıcalıkları yükseltildiğinde, kimlik
    doğrulamasından sonra yapıldığı gibi <emphasis>yeniden
    oluşturulmalıdır</emphasis>. Kimlik doğrulama bilgisi $_SESSION dizisine
    atamadan önce <function>session_regenerate_id</function> çağrılmalıdır.
    (PHP 7.0.0'dan itibaren, <function>session_regenerate_id</function>, zaman
    damgasını/ve benzerlerini geçerli oturuma kaydetmek için mevcut oturum
    verilerini otomatik olarak kaydeder.) Yalnızca yeni oturumun doğrulanmış
    bayrağı içerdiğinden emin olun.
   </para>

   <para>
    Geliştiriciler,
    <link linkend="ini.session.gc-maxlifetime">session.gc_maxlifetime</link>
    değerine göre oturum kimliğinin süresinin dolmasına güvenmemelidir.
    Saldırganlar, süresinin dolmasını önlemek ve kimliği doğrulanmış bir oturum
    da dahil olmak üzere oturumu kullanmaya devam edebilmek için bir kurbanın
    oturum kimliğine düzenli aralıklarla erişebilir.
   </para>

   <para>
    Bunun yerine, geliştiricilerin zaman damgasına dayalı oturum verisi
    yönetimini gerçeklemesi gerekir.
   </para>

   <warning>
    <simpara>
     Oturum yöneticisi zaman damgalarını şeffaf bir şekilde yönetebilse de bu
     özellik uygulanmaz. Eski oturum verileri çöp toplayıcıya gidene kadar
     saklanmalıdır. Aynı zamanda, geliştiriciler, eski oturum verilerinin
     silindiğinden emin olmalıdır. Ancak geliştiriciler, etkin oturum
     verilerini hemen silmemelidir.
     Yani <literal>session_regenerate_id(true);</literal> ve
     <function>session_destroy</function> etkin bir oturum için asla birlikte
     çağrılmamalıdır. Bu çelişkili gelebilir, ancak bu zorunlu bir
     gerekliliktir.
    </simpara>
   </warning>

   <para>
    <function>session_regenerate_id</function> öntanımlı olarak eski
    oturumları <emphasis>silmez</emphasis>. Eski kimliği doğrulanmış
    oturumlar kullanım için mevcut olabilir. Geliştiriciler, eski oturumların
    herkes tarafından tüketilmesini engellemeli, zaman damgalarını kullanarak
    eski oturum verilerine kendi başlarına erişimi yasaklamalıdır.
   </para>

   <warning>
    <simpara>
     Etkin bir oturumun aniden kaldırılması istenmeyen yan etkilere neden olur.
     Sunucuya eşzamanlı bağlantılar olduğunda ve/veya ağ kararsız olduğunda
     oturumlar kaybedilebilir.
    </simpara>
    <simpara>
     Etkin oturumların aniden kaldırılmasıyla olası bir kötü amaçlı erişim
     tespit edilemez.
    </simpara>
    <simpara>
     Geliştiriciler, güncel olmayan oturumları hemen silmek yerine,
     $_SESSION'da kısa süreli bir zaman aşımı (bir zaman damgası) belirlemeli
     ve kulanıcıların oturum verilerine kendi başlarına erişmesi
     engellenmellidir.
    </simpara>
    <simpara>
     Geliştiriciler, <function>session_regenerate_id</function> işleminin
     hemen ardından eski oturum verilerine erişimi yasaklamamalı, daha sonraki
     bir aşamada yasaklamalıdır. Örneğin. kablolu ağ gibi kararlı ağlar için
     birkaç saniye sonra ve cep telefonları veya Wi-Fi gibi kararsız ağlar
     için birkaç dakika sonra.
    </simpara>
    <simpara>
     Bir kullanıcı eski bir oturuma (süresi dolmuş oturum) erişirse, buna
     erişim reddedilmelidir. Ayrıca, bir saldırıyı temsil etmesi muhtemel
     olduğundan, kimlik doğrulamalı durumunun kullanıcının tüm oturumlarından
     kaldırılması önerilir.
    </simpara>
   </warning>

   <para><link
    linkend="ini.session.use-only-cookies">session.use_only_cookies</link> ve
    <function>session_regenerate_id</function> öğelerinin doğru kullanımı,
    saldırganlar tarafından ayarlanan silinemeyen çerezlerle kişisel DoS'a
    neden olabilir. Bu durumda geliştiriciler, kullanıcıları çerezleri
    kaldırmaya davet edebilir ve bir güvenlik sorunundan etkilenebileceklerini
    bildirebilir. Saldırganlar, güvenlik açığı bulunan bir web uygulaması,
    açıkta kalan/kötü niyetli bir tarayıcı eklentisi, fiziksel olarak güvenliği
    ihlal edilmiş bir cihaz vb. aracılığıyla kötü amaçlı çerezler atayabilir.
   </para>

   <warning>
    <simpara>
     DoS riski yanlış anlaşılmasın. <literal>use_strict_mode=On</literal>
     genel oturum kimliği güvenliği için zorunludur! Tüm sitelerin
     <literal>use_strict_mode</literal>'u etkinleştirmesi önerilir.
    </simpara>
    <simpara>
     DoS, yalnızca hesap saldırı altındayken gerçekleşebilir.
     Bir uygulamadaki JavaScript zerki güvenlik açığı en yaygın sebeplerdendir.
    </simpara>
   </warning>

  </sect2>

  <sect2 xml:id="features.session.security.management.session-data-deletion">
   <title>Oturum Verisinin Silinmesi</title>

   <para>
    Eski oturum verisi erişilemez ve silinmiş olmalıdır.
    Geçerli oturum modülü bunu gerektiği gibi yerine getiremez.
   </para>

   <para>
    Eski oturum verileri mümkün olan en kısa sürede silinmelidir. Ancak,
    etkin oturumlar hemen kaldırılmamalıdır. Bu gereksinimleri karşılamak
    için geliştiriciler, zaman damgasına dayalı oturum veri yönetimini kendi
    başlarına uygulamalıdır.
   </para>

   <para>
    $_SESSION içinde zaman aşımı damgasını ayarlayın ve yönetin. Güncel
    olmayan oturum verilerine erişimi yasaklayın. Eski oturum verilerine
    erişim tespit edildiğinde, kullanıcının oturumlarından tüm kimliği
    doğrulanmış durumları kaldırıp onları yeniden kimlik doğrulamaya
    zorlamanız önerilir. Eski oturum verilerine erişim bir saldırıyı temsil
    edebilir. Bunu başarmak için geliştiriciler, her kullanıcının tüm etkin
    oturumlarını takip etmelidir.
   </para>

   <note>
    <simpara>
     Eski bir oturuma erişim, kararsız bir ağ ve/veya siteye eşzamanlı erişim
     nedeniyle de gerçekleşebilir. Örneğin, sunucu bir çerez aracılığıyla yeni
     bir oturum kimliği belirlemeye çalışmış, ancak bağlantının kesilmesi
     nedeniyle Set-Cookie paketi istemciye ulaşmamış olabilir. Bir bağlantıya
     <function>session_regenerate_id</function> tarafından yeni bir oturum
     kimliği verilebilir, ancak başka bir eşzamanlı bağlantı henüz yeni oturum
     kimliğini almamış olabilir. Bu nedenle, geliştiriciler daha sonraki bir
     aşamada eski oturuma erişimi yasaklamalıdır. Yani zaman damgası tabanlı
     oturum yönetimi zorunludur.
    </simpara>
   </note>

   <para>
    Özetle, oturum verileri ne <function>session_regenerate_id</function>
    ne de <function>session_destroy</function> ile yok edilmeli, oturum
    verilerine erişimi denetlemek için zaman damgaları kullanılmalıdır.
    <function>session_gc</function>'nin oturum veri deposundaki eski verileri
    silmesine izin verin.
   </para>

  </sect2>

  <sect2 xml:id="features.session.security.management.session-locking">
   <title>Oturum Kilitleme</title>

   <para>
    Yarış koşullarından kaçınmak için oturum verileri öntanımlı olarak
    kilitlenir. Oturum verilerinin istekler arasındaki tutarlılığını sağlamak
    için kilitleme zorunludur.
   </para>

   <para>
    Ancak oturum kilitleme, saldırganlar tarafından DoS saldırıları
    gerçekleştirmek için kötüye kullanılabilir. Oturum kilitleyerek DoS
    saldırısı riskini azaltmak için kilitleri en aza indirin. Oturum
    verilerinin güncellenmesi gerekmediğinde salt okunur oturumlar kullanın.
    <function>session_start</function> işlevini 'read_and_close' seçeneği ile
    kullanın: <literal>session_start(['read_and_close'=>1]);</literal>
    <function>session_commit</function> kullanarak $_SESSION güncellendikten
    hemen sonra, mümkün olan en kısa sürede oturumu kapatın.
   </para>

   <para>
    Geçerli oturum modülü, oturum etkin olmadığında $_SESSION üzerinde
    herhangi bir değişiklik algılamaz. Oturum etkin değilken $_SESSION
    üzerinde değişiklik yapmamak geliştiricinin sorumluluğundadır.
   </para>

  </sect2>

  <sect2 xml:id="features.session.security.management.active-sessions">
   <title>Etkin Oturumlar</title>

   <para>
    Developers should keep track of all active sessions for every user.
    And notify them of how many active sessions, from which IP (and area),
    how long it has been active, etc.
    PHP does not keep track of these. Developers are supposed to do so.
   </para>

   <para>
    Various ways to implement this exist.
    One possible implementation is setting up a database that keeps track
    of the required data and stores any relevant information.
    Since session data is GCed, developers must take care of the GCed data
    to maintain the active session database consistency.
   </para>

   <para>
    One of the simplest implementations is "User ID prefixed session ID"
    and store the required information in $_SESSION.
    Many databases posses good performance for selecting string prefix.
    Developers MAY use <function>session_regenerate_id</function> and
    <function>session_create_id</function> for this.
   </para>

   <warning>
    <simpara>
     Never employ confidential data as a prefix.
     If the user ID is confidential, consider using
     <function>hash_hmac</function>.
    </simpara>
   </warning>

   <warning>
    <simpara>
     Enabling <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>
     is mandatory for this setup. Ensure it is enabled.
     Otherwise the active session database can be compromised.
    </simpara>
   </warning>

   <para>
    Timestamp based session management is mandatory to detect access to obsolete sessions.
    When access to an obsolete session is detected, authentication flags should
    be removed from all active sessions of the user.
    This prevents attackers to keep exploiting stolen sessions.
   </para>

  </sect2>

  <sect2 xml:id="features.session.security.management.session-and-autologin">
   <title>Oturum ve Otomatik Oturum Açmak</title>

   <para>
    Developers must not use long life session IDs for auto-login because it
    increases the risk of stolen sessions.
    An auto-login feature should be implemented by the developer.
   </para>

   <para>
    Use a secure one time hash key as an auto-login key using
    <function>setcookie</function>. Use a secure hash stronger than SHA-2.
    E.g. SHA-256 or greater with random data from <function>random_bytes</function>
    or /dev/urandom.
   </para>

   <para>
    If the user is unauthenticated, check whether the one-time auto-login key is valid or not.
    In the case it is valid, authenticate the user and set a new secure one-time hash key.
    An auto-login key must only be used once, i.e. never reuse an auto-login key,
    always generate a new one.
   </para>

   <para>
    An auto-login key is a long life authentication key,
    it should be protected as much as possible.
    Use path/httponly/secure/SameSite cookie attributes to secure it.
    I.e. never transmit the auto-login key unless required.
   </para>

   <para>
    Developer must implement the features that disables
    auto-login and removes unneeded auto-login key cookie.
   </para>

  </sect2>

  <sect2 xml:id="features.session.security.management.csrf">
   <title>CSRF (Siteler Arası Talep Sahtekarlıkları) Saldırıları</title>

   <para>
    Sessions and authentication do not protect against CSRF attacks.
    Developers must implement CSRF protection by themselves.
   </para>

   <para>
    <function>output_add_rewrite_var</function> can be used for CSRF protection.
    Refer to the manual page for more details.
   </para>

   <note>
    <simpara>
     PHP prior to 7.2.0 uses the same output buffer and INI setting as trans sid.
     Therefore, use of <function>output_add_rewrite_var</function>
     with PHP prior to version 7.2.0 is not advised.
    </simpara>
   </note>

   <para>
    Most web application frameworks support CSRF protection.
    Refer to the web application framework manual for more details.
   </para>

   <para>
    As of PHP 7.3 the SameSite attribute for the session cookie can be set.
    This is an additional measure which can mitigate CSRF vulnerabilities.
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="session.security.ini">
  <title>Oturum INI Ayarlarının Güvenliği</title>

  <para>
   By securing session related INI settings, developers can improve session security.
   Some important INI settings do not have any recommended settings.
   Developers are responsible for hardening session settings.
  </para>

  <itemizedlist>
    <listitem>
     <para>
      <link linkend="ini.session.cookie-lifetime">session.cookie_lifetime</link>=0
     </para>
     <para>
      <literal>0</literal> possesses a particular meaning.
      It informs browsers not to store the cookie to permanent storage.
      Therefore, when the browser is terminated, the session ID cookie is deleted immediately.
      If developers set this other than 0, it may allow other users to use the session ID.
      Most applications should use "<literal>0</literal>" for this.
     </para>
     <para>
      If an auto-login feature is required,
      developers must implement their own secure auto-login feature.
      Do not use long life session IDs for this.
      More information can be found above in the relevant section.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.use-cookies">session.use_cookies</link>=On
     </para>
     <para>
      <link linkend="ini.session.use-only-cookies">session.use_only_cookies</link>=On
     </para>
     <para>
      Although HTTP cookies suffer some problems,
      cookies remain the preferred way to manage session IDs.
      Only use cookies for session ID management when it is possible.
      Most applications should use a cookie for the session ID.
     </para>
     <para>
      If <literal>session.use_only_cookies</literal>=Off,
      the session module will use the session ID values set by
      GET/POST/URL provided the session ID cookie is uninitialized.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.use-strict-mode">session.use_strict_mode</link>=On
     </para>
     <para>
      Although, enabling <literal>session.use_strict_mode</literal>
      is mandatory for secure sessions. It is disabled by default.
     </para>
     <para>
      This prevents the session module to use an uninitialized session ID.
      Put differently, the session module only accepts valid session IDs
      generated by the session module.
      It rejects any session ID supplied by users.
     </para>
     <para>
      Due to the cookie specification, attackers are capable to place
      non removable session ID cookies by locally setting a cookie database
      or JavaScript injections.
      <literal>session.use_strict_mode</literal> can prevent an attacker
      initialized session ID of being used.
     </para>
     <note>
      <para>
       Attackers may initialize a session ID with their device and may set
       the session ID of the victim. They must keep the session ID active to abuse.
       Attackers require additional steps to perform an attack in this scenario.
       Therefore, <literal>session.use_strict_mode</literal> works as a mitigation.
      </para>
     </note>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.cookie-httponly">session.cookie_httponly</link>=On
     </para>
     <para>
      Refuses access to the session cookie from JavaScript.
      This setting prevents cookies snatched by a JavaScript injection.
     </para>
     <para>
      It is possible to use a session ID as a CSRF token, but this is not recommended.
      For example, HTML sources may be saved and sent to other users.
      Developers should not write session IDs in web pages for better security.
      Almost all applications must use the httponly attribute for the session ID cookie.
     </para>
     <note>
      <para>
       The CSRF token should be renewed periodically just like the session ID.
      </para>
     </note>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.cookie-secure">session.cookie_secure</link>=On
     </para>
     <para>
      Allow access to the session ID cookie only when the protocol is HTTPS.
      If a website is only accessible via HTTPS, it should enable this setting.
     </para>
     <para>
      HSTS should be considered for websites accessible only via HTTPS.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.cookie-samesite">session.cookie_samesite</link>="Lax" or
      <link linkend="ini.session.cookie-samesite">session.cookie_samesite</link>="Strict"
     </para>
     <para>
      As of PHP 7.3 the <literal>"SameSite"</literal> attribute can be set for the session ID cookie.
      This attribute is a way to mitigate CSRF (Cross Site Request Forgery) attacks.
     </para>
     <para>
      The difference between Lax and Strict is the accessibility of the cookie in
      requests originating from another registrable domain employing the HTTP GET method.
      Cookies using Lax will be accessible in a GET request originated from
      another registrable domain, whereas cookies using Strict will not.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.gc-maxlifetime">session.gc_maxlifetime</link>=[choose smallest possible]
     </para>
     <para>
      <literal>session.gc_maxlifetime</literal>
      is a setting for deleting obsolete session ID.
      Reliance on this setting is <emphasis>not</emphasis> recommended.
      Developers should manage the lifetime of sessions with a timestamp by themselves.
     </para>
     <para>
      Session GC (garbage collection) is best performed by using <function>session_gc</function>.
      The <function>session_gc</function> function should be executed by a task
      managers. E.g. cron on UNIX like systems.
     </para>
     <para>
      GC is performed by probability by default.
      This setting does <emphasis>not</emphasis> guarantee that an outdated
      session is deleted.
      Although developers cannot rely on this setting,
      specifying it to the smallest possible value is recommended.
      Adjusting <link
      linkend="ini.session.gc-probability">session.gc_probability</link>
      and <link
      linkend="ini.session.gc-divisor">session.gc_divisor</link> so
      that obsolete sessions are deleted at an appropriate frequency.
      If an auto-login feature is required, developers must implement their own
      secure auto-login feature, see above for more information.
      Never use long life session ID for this feature.
     </para>
     <note>
      <para>
       Some session save handler modules do not use this setting for probability
       based expiration. E.g. memcached, memcache.
       Refer to the session save handler documentation for details.
      </para>
     </note>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.use-trans-sid">session.use_trans_sid</link>=Off
     </para>
     <para>
      Use of a transparent session ID management is not prohibited.
      Developers may employ it when it is required.
      However, disabling transparent session ID management improves the general session
      ID security by eliminating the possibility of a session ID injection and/or leak.
     </para>
     <note>
      <para>
       Session ID may leak from bookmarked URLs, e-mailed URLs, saved HTML source, etc.
      </para>
     </note>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.trans-sid-tags">session.trans_sid_tags</link>=[limited tags]
     </para>
     <para>
      (PHP 7.1.0 &gt;=) Developers should not rewrite unneeded HTML tags.
      Default value should be sufficient for most usages.
      Older PHP versions use
      <link linkend="ini.url-rewriter.tags">url_rewriter.tags</link> instead.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.trans-sid-hosts">session.trans_sid_hosts</link>=[limited hosts]
     </para>
     <para>
      (PHP 7.1.0 &gt;=) This INI defines whitelist hosts that allows trans sid rewrite.
      Never add untrusted hosts.
      Session module only allows <literal>$_SERVER['HTTP_HOST']</literal>
      when this setting is empty.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.referer-check">session.referer_check</link>=[originating URL]
     </para>
     <para>
      When <link
      linkend="ini.session.use-trans-sid">session.use_trans_sid</link>
      is enabled.
      It reduces the risk of session ID injection.
      If a website is http://example.com/, set http://example.com/ to it.
      Note that with HTTPS browsers will not send the referrer header.
      Browsers may not send the referrer header by configuration.
      Therefore, this setting is not a reliable security measure.
      Use of this setting is recommended.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.cache-limiter">session.cache_limiter</link>=nocache
     </para>
     <para>
      Ensure HTTP content are uncached for authenticated sessions.
      Allow caching only when the content is not private.
      Otherwise, content may be exposed. "private" may be employed if HTTP content does not
      include security sensitive data.
      Note that "private" may transmit private data cached by shared clients.
      "public" must only be used when HTTP content does not contain any private data at all.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.sid-length">session.sid_length</link>="48"
     </para>
     <para>
      (PHP 7.1.0 &gt;=) Longer session IDs results in stronger session IDs.
      Developers should consider a session ID length of 32 characters or more.
      At least 26 characters are required when
      <link linkend="ini.session.sid-bits-per-character">session.sid_bits_per_character</link>="5".
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.sid-bits-per-character">session.sid_bits_per_character</link>="6"
     </para>
     <para>
      (PHP 7.1.0 &gt;=) The more bits there are in a session ID character,
      the stronger the session ID generated by the session module is for an
      identical session ID length.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.hash-function">session.hash_function</link>="sha256"
     </para>
     <para>
      (PHP 7.1.0 &lt;) A stronger hash function will generate a stronger session ID.
      Although hash collision is unlikely even with the MD5 hashing algorithm,
      developers should use SHA-2 or a stronger hashing algorithm like sha384 and sha512.
      Developers must ensure they feed a long enough
      <link linkend="ini.session.entropy-length">entropy</link>
      for the hashing function used.
     </para>
    </listitem>

    <listitem>
     <para>
      <link linkend="ini.session.save-path">session.save_path</link>=[non world-readable directory]
     </para>
     <para>
      If this is set to a world-readable directory, such as
      <filename>/tmp</filename> (the default), other users on the
      server may be able to hijack sessions by getting the list of
      files in that directory.
     </para>
    </listitem>

  </itemizedlist>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

